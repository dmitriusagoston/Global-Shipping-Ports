<!DOCTYPE html>
<meta charset="utf-8">
<style>
	.same {
		display: none;
	}
	
    #port-change {
        position: absolute;
        top: 450px;
        left: 10px;
    }
	
	div.tooltip {	
		position: absolute;
		text-align: center;
		width: 150px;
		padding: 2px;				
		font: 12px sans-serif;		
		background: lightsteelblue;	
		border: 0px;		
		border-radius: 8px;			
		pointer-events: none;			
	}
	
	.column {
		float: left;
		padding: 0px;
	}
	.left, .right {
		width: 25%;
	}
	.middle1, .middle2 {
		width: 25%;
	}
	
	div.author {
		font-size: 16px;
    	text-align: center;
		background-color: aliceblue;
	}
	
	.row:after {
            content: "";
            display: table;
            clear: both;
	}
	.author {
		line-height: 1;
	}
	#chart {
		position:absolute;
	}
	.line {
	  fill: none;
	  stroke: #EF5285;
	  stroke-width: 2px;
	}
    
    .line {
      fill: none;
      stroke-width: 1.5px;
    }

    .grid line {
      stroke: lightgrey;
      stroke-opacity: 0.7;
      shape-rendering: crispEdges;
    }

    .grid path {
      stroke-width: 0;
    }
</style>

<!-- Load d3.js and the geo projection plugin -->
<script src="https://d3js.org/d3.v4.js"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>

<html>
	<h1 style = "text-align:center"><bold>Global Shipping Ports</bold></h1>
	
	<button id="port-change" type="button">Switch Port Radius</button>

	<!-- Create an element where the map will take place -->
	<svg id="portMap" width="500" height="400"></svg>
  <svg id="portLine" width="600" height="400"></svg>
	<p>This visualization shows a world map with various shipping ports as circles. The radius of the circle gets larger as the volume of goods being transferred increases while the color of the circle gets lighter as the political value of the port increases. The volume of goods is being measured in Twenty-foot Equivalent Units (TEUs). There is a correlation between the color and the size of the circles as larger ports hold more political power.</p>
	
	
	<div class = 'author'>
		<h4 style="font-style: italic"><br/>Created by</h4>
			<p style="position:relative;top:0px;right:0px; font-size:16px; text-align:center;" id="myParagraph">
				Dmitrius Agoston (dagoston@ucsc.edu)<br> 
				Benjamin Birnbaum (bbirnbau@ucsc.edu)<br>
				Anna Yu (antyu@ucsc.edu)<br>
				in collaboration with Suresh K. Lodha, Jacob Low, and Omkar Ghanekar</p>
		<p><strong><em>Github Link:</em></strong> <a href="https://github.com/dmitriusagoston/Global-Shipping-Ports">https://github.com/dmitriusagoston/Global-Shipping-Ports/</a></p>
		<h4 style="font-style: italic"><br/>Designed for</h4>
			<p id="myParagraph">CSE 163: Data Programming for Visualization, Fall 2022</p>
		
		<div class="row">
          <div class="column left">
            <b>Files</b>
            <p>index.html<br>README.md<br>
				TEUByYear.csv<br>top100port.csv<br>world.json</p>
          </div>
          <div class="column middle1">
            <b>Data Sources</b>
            <p>
            	<a href="https://data.humdata.org/dataset/global-ports">Global Port Dataset</a><br>
				<a href="https://lloydslist.maritimeintelligence.informa.com/one-hundred-container-ports-2020">Top 100 Ports</a><br>
				<a href="https://datacatalog.worldbank.org/search/dataset/0038118">Global - International Ports</a><br>
            </p>
          </div>
          <div class="column middle2">
            <b>Visualization Sources</b>
			<p>
				<a href="https://d3-graph-gallery.com/graph/bubblemap_template.html">Bubble Map</a><br>
				<a href="https://bl.ocks.org/piwodlaiwo/3734a1357696dcff203a94012646e932">World Map</a><br>
        	</p>
          </div>
          <div class="column right">
            <b>Code Sources</b>
            <p>
				<a href="https://d3-graph-gallery.com/graph/bubblemap_template.html">Bubble Map</a><br>
				<a href="https://bl.ocks.org/piwodlaiwo/3734a1357696dcff203a94012646e932">World Map</a><br>
			</p>
          </div>
        </div>
	</div>
</html>
	
<script>

// The svg
var svg = d3.select("#portMap"),
    width = +svg.attr("width"),
    height = +svg.attr("height")

/*
    svg.call(d3.zoom().on("zoom", function () {
          svg.attr("transform", d3.event.transform)
    }))
    svg.append("g")
*/

var color = d3.scaleThreshold()
    .domain([0, 1, 3, 5, 10, 15, 20, 30, 40, 45, 50])
    .range(["#0d0887","#41049d","#6a00a8","#8f0da4","#b12a90","#cc4778","#e16462","#f2844b","#fca636","#fcce25","#f0f921"]);
    
// Map and projection
var path = d3.geoPath();
var projection = d3.geoMercator()
  .scale(70)
  .center([0,20])
  .translate([width / 2, (height / 2) + 25]);
  

d3.queue()
  .defer(d3.json, "world.json")  // World shape
  .defer(d3.csv, "top100port.csv") // Position of circles
  .await(ready);
	
//Define Tooltip here
// create a tooltip
var div = d3.select("body").append("div")	
	.attr("class", "tooltip")				
	.style("opacity", 0);
    
function ready(error, dataGeo, data) {

var valueExtent = d3.extent(data, function(d) { return +d.size; })

  // Add a scale for bubble size
  var size = d3.scaleSqrt()
    .domain(valueExtent)  // What's in the data
    .range([ 1, 15])  // Size in pixel

  // Draw the map
  svg.append("g")
    .selectAll("path")
    .data(dataGeo.features)
    .enter()
    .append("path")
      // draw each country
      .attr("d", d3.geoPath()
        .projection(projection)
      )
      .attr("fill", "#DDD")
      .attr("stroke", "#999")
      .attr("stroke-width", 0.5)
    
  // Add circles:
  svg.selectAll("myCircles")
    .data(data.sort(function(a,b) { return +b.size - +a.size }).filter(function(d,i){ return i<1000 }))
    .enter()
    .append("circle")
	  .attr("class", "diff")
      .attr("cx", function(d){ return projection([+d.lon, +d.lat])[0] })
      .attr("cy", function(d){ return projection([+d.lon, +d.lat])[1] })
      .attr("r", function(d){ return size(+d.size) })
      .attr("stroke-width", 1)
      .attr("fill", function(d){ return color(+d.size) })
      .attr("fill-opacity", .4)
      .attr("id", function(d) { return "bigC" + d.name; })
	  .on("mouseover", function(d) { // tooltip
			div.transition()		
				.duration(200)		
				.style("opacity", .9);		
			div.html(function() { // what tooltip says
				var str = "Name: " + d.name + " Port <br>";
				str += "Volume: " + d.size + " Million TEU <br>";
                str += "Port Type: " + d.type + " Port <br>";
                str += "Can Support Military: " + d.military;
				return str;
			})	
				.style("left", (d3.event.pageX) + "px") // where tooltip appears
				.style("top", (d3.event.pageY) + "px");
			})					
      .on("mouseout", function(d) { // after mouse leaves
          div.transition()		
              .duration(500)		
              .style("opacity", 0);	
      })
      .on("click", function(d) {
          let line = g.select("#" + d.name);
          if (line.attr("visibility") == "visible") {
              line.attr("visibility", "hidden");
          } else {
              line.attr("visibility", "visible");
          }
      if (d.clicked == "FALSE") {
          d.clicked = "TRUE"
          d3.select(this)
            .attr("fill" , "#00ffff")
            .attr("fill-opacity", 1)
          d3.select("#smallC" + d.name)
            .attr("fill" , "#00ffff")
            .attr("fill-opacity", 1)
        } else {
          d.clicked = "FALSE"
          d3.select(this)
            .attr("fill", function(d){ return color(+d.size) })
            .attr("fill-opacity", 0.7)
          d3.select("#smallC" + d.name)
            .attr("fill", function(d){ return color(+d.size) })
            .attr("fill-opacity", 0.7)
        }
      });

  svg.selectAll("myCircles")
    .data(data.sort(function(a,b) { return +b.size - +a.size }).filter(function(d,i){ return i<1000 }))
    .enter()
    .append("circle")
	  .attr("class", "same")
      .attr("cx", function(d){ return projection([+d.lon, +d.lat])[0] })
      .attr("cy", function(d){ return projection([+d.lon, +d.lat])[1] })
      .attr("r", function(d){ return size(2) })
      .attr("stroke-width", 0.3)
      .attr("fill", function(d){ return color(+d.size) })
      .attr("fill-opacity", .7)
      .attr("stroke", "#333")
      .attr("id", function(d) { return "smallC" + d.name; })
	  .on("mouseover", function(d) { // tooltip
			div.transition()		
				.duration(200)		
				.style("opacity", .9);		
			div.html(function() { // what tooltip says
				var str = "Name: " + d.name + " Port <br>";
				str += "Volume: " + d.size + " Million TEU <br>";
                str += "Port Type: " + d.type + " Port <br>";
                str += "Can Support Military: " + d.military;
				return str;
			})	
				.style("left", (d3.event.pageX) + "px") // where tooltip appears
				.style("top", (d3.event.pageY) + "px");
			})					
		.on("mouseout", function(d) { // after mouse leaves
			div.transition()		
				.duration(500)		
				.style("opacity", 0);	
		})
    .on("click", function(d) {
        let line = g.select("#" + d.name);
        if (line.attr("visibility") == "visible") {
            line.attr("visibility", "hidden");
        } else {
            line.attr("visibility", "visible");
        }
    if (d.clicked == "FALSE") {
        d.clicked = "TRUE"
        d3.select(this)
          .attr("fill" , "#00ffff")
          .attr("fill-opacity", 1)
        d3.select("#bigC" + d.name)
          .attr("fill" , "#00ffff")
          .attr("fill-opacity", 1)
      } else {
        d.clicked = "FALSE"
        d3.select(this)
          .attr("fill", function(d){ return color(+d.size) })
          .attr("fill-opacity", 0.7)
        d3.select("#bigC" + d.name)
          .attr("fill", function(d){ return color(+d.size) })
          .attr("fill-opacity", 0.7)
      }
    });
}
    
d3.select("#port-change").on("click", function(){
	const check = document.querySelectorAll(".diff");
	const check2 = document.querySelectorAll(".same");
	if (check[0].style.display == '') {
		for (let i = 0; i < check.length; i++) {
			check[i].style.display = "none";
		}
		for (let i = 0; i < check2.length; i++) {
			check2[i].style.display = "block";
		}
	} else {
		for (let i = 0; i < check.length; i++) {
			check[i].style.display = "";
		}
		for (let i = 0; i < check2.length; i++) {
			check2[i].style.display = "none";
		}
	}
});
    
var x = d3.scaleSqrt()
    .domain([0, 50])
    .rangeRound([240, 490]);

var g = svg.append("g")
    .attr("class", "key")
    .attr("transform", "translate(0,40)");
 

g.selectAll("rect")
  .data(color.range().map(function(d) {
      d = color.invertExtent(d);
      if (d[0] == null) d[0] = x.domain()[0];
      if (d[1] == null) d[1] = x.domain()[1];
      return d;
    }))
  .enter().append("rect")
    .attr("height", 8)
    .attr("x", function(d) { return x(d[0]); })
    .attr("width", function(d) { return x(d[1]) - x(d[0]); })
    .attr("fill", function(d) { return color(d[0]); });

g.append("text")
    .attr("class", "caption")
    .attr("x", x.range()[0])
    .attr("y", -5)
    .attr("fill", "#000")
    .attr("text-anchor", "start")
    .attr("font-weight", "bold")
    .text("Volume Transported (Million TEU)")

g.call(d3.axisBottom(x)
    .tickSize(13)
    .tickValues(color.domain()))
  .select(".domain")
    .remove();
    
var zoom = d3.zoom()
      .scaleExtent([1, 8])
      .on('zoom', function() {
          
          svg.selectAll("circle")
           .attr('transform', d3.event.transform)
          
          svg.selectAll('path')
           .attr('transform', d3.event.transform);
          
});

svg.call(zoom);
</script>
<script>
// Multiline -----------------------------------------------------------------
var svg2 = d3.select("#portLine"),
    margin = {top: 25, right: 80, bottom: 40, left: 50},
    width = svg2.attr("width") - margin.left - margin.right,
    height = svg2.attr("height") - margin.top - margin.bottom,
    g = svg2.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var parseTime = d3.timeParse("%Y");

// X axis is time based on the width and y axis is linear based on the height
// The "z" here is used ot give the lines color later
var x = d3.scaleTime().range([0, width]),
    y = d3.scaleLinear().range([height, 0]),
    z = d3.scaleOrdinal(d3.schemeCategory10);

var line = d3.line()
    .curve(d3.curveLinear)
    .x(function(d) { return x(d.year); })
    .y(function(d) { return y(d.TEU); });

// These functions use axis and tick marks to serve as gridlines
function make_x_gridlines() {		
    return d3.axisBottom(x)
        .ticks(10)
}

function make_y_gridlines() {		
    return d3.axisLeft(y)
        .ticks(10)
}

d3.csv("TEUByYear.csv", type, function(error, data) {
  if (error) throw error;

  // Creates an array containing the port names (col 1 of data except 1st element) and their values
  var ports = data.columns.slice(1).map(function(id) {
    return {
      id: id,
      values: data.map(function(d) {
        return {year: d.year, TEU: d[id]};
      })
    };
  });
  
  // Sets the x domain to [min year, max year]
  x.domain(d3.extent(data, function(d) { return d.year; }));

  // Sets the y domain to [min BTU, max BTU]
  y.domain([
    d3.min(ports, function(c) { return d3.min(c.values, function(d) { return d.TEU; }); }),
    d3.max(ports, function(c) { return d3.max(c.values, function(d) { return d.TEU; }); })
  ]);
  
  // Sets the z domain to each color the lines will be
  z.domain(ports.map(function(c) { return c.id; }));
  
  // Makes the x gridlines
  g.append("g")			
    .attr("class", "grid")
    .attr("transform", "translate(0," + height + ")")
    .call(make_x_gridlines()
        .tickSize(-height)
        .tickFormat("")
    )

  // Makes the y gridlines
  g.append("g")			
      .attr("class", "grid")
      .call(make_y_gridlines()
          .tickSize(-width)
          .tickFormat("")
      )

  // Makes the x axis and its title
  g.append("g")
      .attr("class", "axis axis--x")
      .attr("transform", "translate(0," + height + ")")
      .call(d3.axisBottom(x))
    .append("text")
      .attr("x", 200)
      //.attr("y", -10)
      .attr("dy", "2.5em")
      .attr("fill", "#000")
      .attr("font-size", "15px")
      .style("text-anchor", "middle")
      .text("Year");

  // Makes the y axis and its title
  g.append("g")
      .attr("class", "axis axis--y")
      .call(d3.axisLeft(y))
    .append("text")
      .attr("transform", "rotate(-90)")
      .attr("x", -200)
      .attr("dy", "-2.5em")
      .attr("fill", "#000")
      .attr("font-size", "15px")
      .style("text-anchor", "middle")
      .text("Consumption (Million BTU/person)");

  // Sets up an appendable object for each port
  var port = g.selectAll(".port")
    .data(ports)
    .enter().append("g")
      .attr("class", "port")
      .attr("id", function(d) { return d.id; })
      .attr("visibility", "hidden");
    
  // Creates the lines for each port
  var path = port.append("path")
      .attr("class", "line")
      .attr("d", function(d) { return line(d.values); })
      // Gives the lines color using z
      .style("stroke", function(d) { return z(d.id); });

  // totalLength used in animation
  var totalLength = path.node().getTotalLength();

  // Creates an "ease in" animation for the lines
  path
      .attr("stroke-dasharray", totalLength + " " + totalLength)
      .attr("stroke-dashoffset", totalLength)
      .transition()
        .duration(2000)
        .ease(d3.easeLinear)
        .attr("stroke-dashoffset", 0);

  // Adds text at the end of each port's line
  port.append("text")
      .datum(function(d) { return {id: d.id, value: d.values[d.values.length - 1]}; })
      .attr("transform", function(d) { return "translate(" + x(d.value.year) + "," + y(d.value.TEU) + ")"; })
      .attr("x", 3)
      .attr("dy", "0.35em")
      .style("font", "10px sans-serif")
      .text(function(d) { return d.id; })
      .on("click", function(d) {
        let line = g.select("#" + d.id);
        if (line.attr("visibility") == "visible") {
            line.attr("visibility", "hidden");
            svg.select("#bigC" + d.id).attr("fill", function(d){ return color(+d.size) })
            .attr("fill-opacity", 0.7)
            svg.select("#smallC" + d.id).attr("fill", function(d){ return color(+d.size) })
            .attr("fill-opacity", 0.7)
        } else {
            line.attr("visibility", "visible");
        }
      })
});

// Sets up the data used to parse 
function type(d, _, columns) {
  d.year = parseTime(d.year);
  for (var i = 1, n = columns.length, c; i < n; ++i) d[c = columns[i]] = +d[c];
  return d;
}
</script>
<!--<script type="text/javascript" src="FinalMultiline.js"></script> -->
